"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FlowDocumentsVisitor = void 0;
const tslib_1 = require("tslib");
const flow_selection_set_processor_js_1 = require("./flow-selection-set-processor.js");
const graphql_1 = require("graphql");
const flow_1 = require("@graphql-codegen/flow");
const visitor_plugin_common_1 = require("@graphql-codegen/visitor-plugin-common");
class FlowSelectionSetToObject extends visitor_plugin_common_1.SelectionSetToObject {
    getUnknownType() {
        return 'any';
    }
    createNext(parentSchemaType, selectionSet) {
        return new FlowSelectionSetToObject(this._processor, this._scalars, this._schema, this._convertName.bind(this), this._getFragmentSuffix.bind(this), this._loadedFragments, this._config, parentSchemaType, selectionSet);
    }
}
const auto_bind_1 = tslib_1.__importDefault(require("auto-bind"));
class FlowDocumentsVisitor extends visitor_plugin_common_1.BaseDocumentsVisitor {
    constructor(schema, config, allFragments) {
        super(config, {
            useFlowExactObjects: (0, visitor_plugin_common_1.getConfigValue)(config.useFlowExactObjects, true),
            useFlowReadOnlyTypes: (0, visitor_plugin_common_1.getConfigValue)(config.useFlowReadOnlyTypes, false),
        }, schema);
        (0, auto_bind_1.default)(this);
        const wrapArray = (type) => `${this.config.useFlowReadOnlyTypes ? '$ReadOnlyArray' : 'Array'}<${type}>`;
        const wrapOptional = (type) => `?${type}`;
        const { useFlowReadOnlyTypes } = this.config;
        const formatNamedField = (name, type, isConditional = false) => {
            const optional = (!!type && !(0, graphql_1.isNonNullType)(type)) || isConditional;
            return `${useFlowReadOnlyTypes ? '+' : ''}${name}${optional ? '?' : ''}`;
        };
        const processorConfig = {
            namespacedImportName: this.config.namespacedImportName,
            convertName: this.convertName.bind(this),
            enumPrefix: this.config.enumPrefix,
            scalars: this.scalars,
            formatNamedField,
            wrapTypeWithModifiers(baseType, type) {
                return (0, visitor_plugin_common_1.wrapTypeWithModifiers)(baseType, type, { wrapOptional, wrapArray });
            },
        };
        const processor = config.preResolveTypes
            ? new visitor_plugin_common_1.PreResolveTypesProcessor(processorConfig)
            : new flow_selection_set_processor_js_1.FlowWithPickSelectionSetProcessor({
                ...processorConfig,
                useFlowExactObjects: this.config.useFlowExactObjects,
            });
        const enumsNames = Object.keys(schema.getTypeMap()).filter(typeName => (0, graphql_1.isEnumType)(schema.getType(typeName)));
        this.setSelectionSetHandler(new FlowSelectionSetToObject(processor, this.scalars, this.schema, this.convertName.bind(this), this.getFragmentSuffix.bind(this), allFragments, this.config));
        this.setVariablesTransformer(new flow_1.FlowOperationVariablesToObject(this.scalars, this.convertName.bind(this), this.config.namespacedImportName, enumsNames, this.config.enumPrefix, {}, true));
    }
    getPunctuation(declarationKind) {
        return declarationKind === 'type' ? ',' : ';';
    }
    getImports() {
        return !this.config.globalNamespace && !this.config.inlineFragmentTypes
            ? this.config.fragmentImports
                // In flow, all non ` * as x` imports must be type imports
                .map(fragmentImport => ({ ...fragmentImport, typesImport: true }))
                .map(fragmentImport => (0, visitor_plugin_common_1.generateFragmentImportStatement)(fragmentImport, 'type'))
            : [];
    }
}
exports.FlowDocumentsVisitor = FlowDocumentsVisitor;
