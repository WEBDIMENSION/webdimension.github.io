"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.typegenMachine = void 0;

var _lodash = _interopRequireDefault(require("lodash"));

var _xstate = require("xstate");

var _utils = require("./utils");

const typegenMachine = (0, _xstate.createMachine)({
  tsTypes: {},
  schema: {
    context: {},
    events: {}
  },
  initial: 'initializing',
  on: {
    CREATE_DEV_SERVER: {
      actions: 'assignDevMode'
    }
  },
  states: {
    initializing: {
      type: 'parallel',
      on: {
        SET_SCHEMA: {
          actions: ['assignSchema', _xstate.actions.send('CHECK_IF_READY')]
        },
        SET_GRAPHQL_DEFINITIONS: {
          actions: ['assignThirdpartyDefinitions', 'assignDefinitions', _xstate.actions.send('CHECK_IF_READY')]
        },
        CHECK_IF_READY: {
          cond: 'ready?',
          target: 'runningOnce'
        }
      }
    },
    runningOnce: {
      initial: 'running',
      states: {
        running: {
          type: 'parallel',
          states: {
            emitSchema: {
              initial: 'running',
              states: {
                running: {
                  invoke: {
                    src: 'emitSchema',
                    onDone: 'done',
                    onError: {
                      target: 'done',
                      actions: 'reportEmitSchemaError'
                    }
                  }
                },
                done: {
                  type: 'final'
                }
              }
            },
            emitPluginDocument: {
              initial: 'running',
              states: {
                running: {
                  invoke: {
                    src: 'emitPluginDocument',
                    onDone: 'done',
                    onError: {
                      target: 'done',
                      actions: 'reportEmitPluginDocumentError'
                    }
                  }
                },
                done: {
                  type: 'final'
                }
              }
            },
            codegen: {
              initial: 'running',
              states: {
                running: {
                  invoke: {
                    src: 'codegen',
                    onDone: 'done',
                    onError: {
                      target: 'done',
                      actions: 'reportCodegenError'
                    }
                  }
                },
                done: {
                  type: 'final'
                }
              }
            },
            autofix: {
              initial: 'running',
              states: {
                running: {
                  invoke: {
                    src: 'autofix',
                    onDone: 'done',
                    onError: {
                      target: 'done',
                      actions: 'reportAutofixError'
                    }
                  }
                },
                done: {
                  type: 'final'
                }
              }
            }
          },
          onDone: [{
            cond: 'devMode?',
            target: '#watching'
          }, {
            target: 'idle'
          }]
        },
        idle: {
          on: {
            CREATE_DEV_SERVER: '#watching'
          }
        }
      }
    },
    watching: {
      type: 'parallel',
      id: 'watching',
      states: {
        schedulers: {
          on: {
            SET_SCHEMA: {
              cond: 'hasSchemaChanged?',
              actions: 'onSchemaChange'
            },
            CHANGE_SCHEMA: {
              actions: 'assignSchema'
            },
            SET_GRAPHQL_DEFINITIONS: {
              cond: 'hasDefinitionsChanged?',
              actions: 'onDefinitionsChange'
            },
            CHANGE_GRAPHQL_DEFINITIONS: {
              actions: 'assignDefinitions'
            }
          }
        },
        jobs: {
          type: 'parallel',
          states: {
            emitSchema: {
              initial: 'idle',
              states: {
                idle: {
                  on: {
                    START_emitSchema: 'running'
                  }
                },
                running: {
                  invoke: {
                    src: 'emitSchema',
                    onDone: {
                      target: 'idle',
                      actions: _xstate.actions.send('DONE_emitSchema')
                    },
                    onError: {
                      target: 'idle',
                      actions: ['reportEmitSchemaError', _xstate.actions.send('DONE_emitSchema')]
                    }
                  }
                }
              }
            },
            codegen: {
              initial: 'idle',
              states: {
                idle: {
                  on: {
                    START_codegen: 'running'
                  }
                },
                running: {
                  invoke: {
                    src: 'codegen',
                    onDone: {
                      target: 'idle',
                      actions: _xstate.actions.send('DONE_codegen')
                    },
                    onError: {
                      target: 'idle',
                      actions: ['reportCodegenError', _xstate.actions.send('DONE_codegen')]
                    }
                  }
                }
              }
            },
            autofix: {
              initial: 'idle',
              states: {
                idle: {
                  on: {
                    START_autofix: 'running'
                  }
                },
                running: {
                  invoke: {
                    src: 'autofix',
                    onDone: {
                      target: 'idle',
                      actions: _xstate.actions.send('DONE_autofix')
                    },
                    onError: {
                      target: 'idle',
                      actions: ['reportAutofixError', _xstate.actions.send('DONE_autofix')]
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}, {
  guards: {
    'devMode?': context => Boolean(context.devMode),
    'ready?': context => Boolean(context.schema && context.trackedDefinitions && context.thirdpartyFragments),
    'hasSchemaChanged?': (context, event) => context.schema !== event.schema,
    'hasDefinitionsChanged?': (context, event) => {
      var _context$trackedDefin;

      const changes = _lodash.default.differenceWith([...(((_context$trackedDefin = context.trackedDefinitions) === null || _context$trackedDefin === void 0 ? void 0 : _context$trackedDefin.values()) || [])], extractTargetDefinitions(event.definitions), _utils.definitionIsEqual);

      return changes.length !== 0;
    }
  },
  actions: {
    assignDevMode: _xstate.actions.assign({
      devMode: _context => true
    }),
    assignSchema: _xstate.actions.assign({
      schema: (_context, event) => (0, _utils.stabilizeSchema)(event.schema)
    }),
    assignThirdpartyDefinitions: _xstate.actions.assign({
      thirdpartyFragments: (_context, event) => extractThirdpartyDefinitions(event.definitions)
    }),
    assignDefinitions: _xstate.actions.assign({
      trackedDefinitions: (_context, event) => filterTargetDefinitions(event.definitions)
    }),
    onSchemaChange: _xstate.actions.pure((_context, event) => {
      const {
        schema
      } = event;
      const emitSchemaJobId = 'SCHEDULED_emitSchema';
      return [_xstate.actions.send({
        type: 'CHANGE_SCHEMA',
        schema
      }), _xstate.actions.cancel(emitSchemaJobId), _xstate.actions.send({
        type: 'START_emitSchema',
        schema
      }, {
        id: emitSchemaJobId,
        delay: context => context.debouncingDelay
      })];
    }),
    onDefinitionsChange: _xstate.actions.pure((context, event) => {
      const {
        schema,
        trackedDefinitions,
        debouncingDelay
      } = context;
      const {
        definitions
      } = event;

      const changes = _lodash.default.differenceWith([...((trackedDefinitions === null || trackedDefinitions === void 0 ? void 0 : trackedDefinitions.values()) || [])], extractTargetDefinitions(definitions), _utils.definitionIsEqual);

      const codegenJobId = 'SCHEDULED_codegen';
      const autofixJobId = 'SCHEDULED_autofix';
      return [_xstate.actions.send({
        type: 'CHANGE_GRAPHQL_DEFINITIONS',
        definitions
      }), _xstate.actions.cancel(codegenJobId), _xstate.actions.send({
        type: 'START_codegen',
        schema,
        definitions
      }, {
        id: codegenJobId,
        delay: debouncingDelay
      }), _xstate.actions.cancel(autofixJobId), _xstate.actions.send({
        type: 'START_autofix',
        files: changes.map(change => change.filePath)
      }, {
        id: autofixJobId,
        delay: debouncingDelay
      })];
    })
  }
});
exports.typegenMachine = typegenMachine;

function extractThirdpartyDefinitions(defMap) {
  return [...defMap.values()].filter(_utils.isThirdpartyFragment);
}

function extractTargetDefinitions(defMap) {
  return [...defMap.values()].filter(_utils.isTargetDefinition);
}

function filterTargetDefinitions(defMap) {
  const defs = [];

  for (const [name, def] of defMap) {
    if ((0, _utils.isTargetDefinition)(def)) {
      defs.push([name, def]);
    }
  }

  return new Map(defs);
}